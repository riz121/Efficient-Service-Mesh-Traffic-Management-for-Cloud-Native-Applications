import time
from collections import defaultdict
import numpy as np

class Microservice:
    def __init__(self, name, replicas, request_limit, pending_requests):
        self.name = name
        self.replicas = replicas
        self.request_limit = request_limit
        self.pending_requests = pending_requests


class MCGBuilder:
    def __init__(self, services, time_window=60):
        """
        :param services: list of Microservice objects
        :param time_window: aggregation window in seconds
        """
        self.services = services
        self.time_window = time_window
        self.V = set()  # vertices
        self.E = defaultdict(dict)  # edges with weights

    def collect_traffic_metrics(self, si, sj):
        """
        Simulate retrieval of metrics between si and sj.
        Replace with actual Prometheus or Istio telemetry in real use.
        """
        # Simulated metrics (random or example values)
        traffic_intensity = np.random.uniform(50, 500)  # requests/sec
        response_time = np.random.uniform(1, 100)  # ms
        return traffic_intensity, response_time

    def compute_moving_average(self, values):
        if not values:
            return 0
        return sum(values) / len(values)

    def build_graph(self):
        # Step 1: Initialize
        print("Building Microservice Communication Graph...")
        for s in self.services:
            # Step 2: Add vertex
            self.V.add(s.name)
        
        # Step 3: Collect communication metrics
        for si in self.services:
            for sj in self.services:
                if si == sj:
                    continue

                λ_values, r_values = [], []
                start_time = time.time()
                
                # Simulate monitoring within time window
                while time.time() - start_time < self.time_window:
                    λ, r = self.collect_traffic_metrics(si, sj)
                    λ_values.append(λ)
                    r_values.append(r)
                    time.sleep(0.1)  # simulate sampling delay

                λ_avg = self.compute_moving_average(λ_values)
                r_avg = self.compute_moving_average(r_values)

                # Step 4: Add edge with weights <λ̄, r̄>
                self.E[si.name][sj.name] = {"traffic_intensity": λ_avg, "response_time": r_avg}

        print("MCG construction complete.")
        return {"vertices": self.V, "edges": self.E}


# Example usage
if __name__ == "__main__":
    # Create microservices
    services = [
        Microservice("productpage", 3, 100, 10),
        Microservice("reviews", 2, 80, 5),
        Microservice("ratings", 2, 50, 3),
        Microservice("details", 1, 30, 2)
    ]

    mcg_builder = MCGBuilder(services, time_window=2)  # small window for demo
    mcg = mcg_builder.build_graph()

    print("\nVertices:", mcg["vertices"])
    print("\nEdges with weights:")
    for src, dests in mcg["edges"].items():
        for dst, w in dests.items():
            print(f"{src} -> {dst}: λ̄={w['traffic_intensity']:.2f}, r̄={w['response_time']:.2f}")
